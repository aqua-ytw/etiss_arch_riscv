import "rv_base/RISCVBase.core_desc"
import "rv_base/RV32I.core_desc"
import "rv_base/RVA.core_desc"
import "rv_base/RV64I.core_desc"

InstructionSet tum_ret extends RISCVBase {
	instructions {
        URET [[no_cont]] {
            encoding: 0b0000000 :: 0b00010 :: 0b00000 :: 0b000 :: 0b00000 :: 0b1110011;
            behavior: {
				CSR[3088] = 0;
				CSR[0] ^= ((CSR[0] & 0x10) >> 4) ^ (CSR[0] & 0x01);
				PC = CSR[65];
				CSR[768] = CSR[0];
				CSR[256] = CSR[0];
			}
        }

        SRET [[no_cont]] {
            encoding: 0b0001000 :: 0b00010 :: 0b00000 :: 0b000 :: 0b00000 :: 0b1110011;
            behavior: {
				CSR[3088] = (CSR[256] & 0x100) >> 8;
				CSR[256] ^= (CSR[256] & 0x100);
				CSR[256] ^= ((CSR[256] & 0x20) >> 4) ^ (CSR[256] & 0x2);
				PC = CSR[321];
				CSR[768]= CSR[256];
				CSR[0]=CSR[256];
			}
        }

        MRET [[no_cont]] {
            encoding: 0b0011000 :: 0b00010 :: 0b00000 :: 0b000 :: 0b00000 :: 0b1110011;
            behavior: {
				CSR[3088] = (CSR[768] & 0x1800) >> 11;
				CSR[768] ^= (CSR[768] & 0x1800);
				CSR[768] ^= ((CSR[768] & 0x80) >> 4) ^ (CSR[768] & 0x8);
				PC = CSR[833];
				CSR[0] = CSR[768];
				CSR[256] = CSR[768];
			}
        }
	}
}

InstructionSet tum_csr extends Zicsr {
    architectural_state {
        unsigned int FFLAGS_N = 0x001;
        unsigned int FRM_N = 0x002;
        unsigned int FCSR_N = 0x003;
        unsigned int SATP = 0x180;
        signed<32> ret = 0;
    }

    functions {
        // black-box function to communicate SATP-changes to MMU
        extern signed<32> ETISS_SIGNAL_MMU(unsigned<XLEN> mmu_signal_) [[etiss_needs_arch]];

        unsigned<XLEN> csr_read(unsigned int csr) {
            if (csr == FFLAGS_N) return CSR[FCSR_N] & 0x1F;
            if (csr == FRM_N) return (CSR[FCSR_N] >> 5) & 0x07;
            return CSR[csr];
        }

        signed<32> csr_write(unsigned int csr, unsigned<XLEN> val) {
            if (csr == FFLAGS_N) CSR[FCSR_N] = (CSR[FCSR_N] & (0x07 << 5)) | (val & 0x1F);
            else if (csr == FRM_N) CSR[FCSR_N] = ((val & 0x07) << 5) | (CSR[FCSR_N] & 0x1F);
            else if (csr == FCSR_N) CSR[FCSR_N] = val & 0xFF;
            else CSR[csr] = val;
            if (csr == SATP) return ETISS_SIGNAL_MMU(val);
            return 0;
        }
    }

    instructions {
        CSRRW {
            encoding: csr[11:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b1110011;
            args_disass:"{name(rd)}, {csr}, {name(rs1)}";
            behavior: {
                unsigned<XLEN> xrd = csr_read(csr);
                unsigned<XLEN> xrs1 = X[rs1];
                ret = csr_write(csr, xrs1);
                if (rd != 0) X[rd] = xrd;
            }
        }

        CSRRS {
            encoding: csr[11:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b1110011;
            args_disass:"{name(rd)}, {csr}, {name(rs1)}";
            behavior: {
                unsigned<XLEN> xrd = csr_read(csr);
                unsigned<XLEN> xrs1 = X[rs1];
                if (rs1 != 0) ret = csr_write(csr, xrd | xrs1);
                if (rd != 0) X[rd] = xrd;
            }
        }

        CSRRC {
            encoding: csr[11:0] :: rs1[4:0] :: 0b011 :: rd[4:0] :: 0b1110011;
            args_disass:"{name(rd)}, {csr}, {name(rs1)}";
            behavior: {
                unsigned<XLEN> xrd = csr_read(csr);
                unsigned<XLEN> xrs1 = X[rs1];
                if (rs1 != 0) ret = csr_write(csr, xrd & ~xrs1);
                if (rd != 0) X[rd] = xrd;
            }
        }

        CSRRWI {
            encoding: csr[11:0] :: zimm[4:0] :: 0b101 :: rd[4:0] :: 0b1110011;
            args_disass:"{name(rd)}, {csr}, {zimm:#0x}";
            behavior: {
                unsigned<XLEN> xrd = csr_read(csr);
                ret = csr_write(csr, (unsigned<XLEN>)zimm);
                if (rd != 0) X[rd] = xrd;
            }
        }

        CSRRSI {
            encoding: csr[11:0] :: zimm[4:0] :: 0b110 :: rd[4:0] :: 0b1110011;
            args_disass:"{name(rd)}, {csr}, {zimm:#0x}";
            behavior: {
                unsigned<XLEN> xrd = csr_read(csr);
                if (zimm != 0) ret = csr_write(csr, xrd | (unsigned<XLEN>)zimm);
                if (rd != 0) X[rd] = xrd;
            }
        }

        CSRRCI {
            encoding: csr[11:0] :: zimm[4:0] :: 0b111 :: rd[4:0] :: 0b1110011;
            args_disass:"{name(rd)}, {csr}, {zimm:#0x}";
            behavior: {
                unsigned<XLEN> xrd = csr_read(csr);
                if (zimm != 0) ret = csr_write(csr, xrd & ~((unsigned<XLEN>)zimm));
                if (rd != 0) X[rd] = xrd;
            }
        }
    }
}

InstructionSet tum_rva extends RV32A {
    architectural_state {
        register unsigned<XLEN> RES_ADDR = -1;
    }

    instructions {
        LRW {
            encoding: 0b00010 :: aq[0:0] :: rl[0:0] :: 0b00000 :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b0101111;
            args_disass: "{name(rd)}, {name(rs1)}, {name(aq)}, {name(rl)}";
            behavior: {
                unsigned<XLEN> offs = X[rs1];
                signed<32> res = (signed<32>)MEM[offs];
                RES_ADDR = offs;
                if (rd) X[rd] = (signed<XLEN>)res;
            }
        }

        SCW {
            encoding: 0b00011 :: aq[0:0] :: rl[0:0] :: rs2[4:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b0101111;
            args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}, {name(aq)}, {name(rl)}";
            behavior: {
                unsigned<XLEN> offs = X[rs1];
                if (RES_ADDR == offs) MEM[offs] = (signed<32>)X[rs2];
                if (rd) X[rd] = RES_ADDR != offs;
                RES_ADDR = -1;
            }
        }
    }
}

// override of memory-operation-instructions to pass memory-address to trap-handler
// hot-fix, technically xtval-csr should only be written when a trap is taken
InstructionSet tum_mem extends RV64I {
    architectural_state {
        unsigned int STVAL = 0x143;
        unsigned int MTVAL = 0x343;
    }

    functions {
        void xtval_write(unsigned<XLEN> addr) {
            CSR[STVAL] = addr;
            CSR[MTVAL] = addr;
        }
    }

    instructions {
        LB {
            encoding: imm[11:0] :: rs1[4:0] :: 0b000 :: rd[4:0] :: 0b0000011;
            args_disass:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + (signed<12>)imm;
                signed<8> res = (signed<8>)MEM[load_address];
                if(rd != 0) X[rd] = (signed<XLEN>)res;
                xtval_write(load_address);
            }
        }

        LH {
            encoding: imm[11:0] :: rs1[4:0] :: 0b001 :: rd[4:0] :: 0b0000011;
            args_disass:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + (signed<12>)imm;
                signed<16> res = (signed<16>)MEM[load_address];
                if (rd != 0) X[rd] = (signed<XLEN>)res;
                xtval_write(load_address);
             }
        }

        LW {
            encoding: imm[11:0] :: rs1[4:0] :: 0b010 :: rd[4:0] :: 0b0000011;
            args_disass:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + (signed<12>)imm;
                signed<32> res = (signed<32>)MEM[load_address];
                if (rd != 0) X[rd] = (signed<XLEN>)res;
                xtval_write(load_address);
            }
        }

        LD {
            encoding: imm[11:0] :: rs1[4:0] :: 0b011 :: rd[4:0] :: 0b0000011;
            args_disass:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> offs = X[rs1] + (signed<12>)imm;
                signed<64> res = (signed<64>)MEM[offs];
                if (rd != 0) X[rd] = (signed<XLEN>)res;
                xtval_write(load_address);
            }
        }

        LBU {
            encoding: imm[11:0] :: rs1[4:0] :: 0b100 :: rd[4:0] :: 0b0000011;
            args_disass:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + (signed<12>)imm;
                unsigned<8> res = (unsigned<8>)MEM[load_address];
                if (rd != 0) X[rd] = (unsigned<XLEN>)res;
                xtval_write(load_address);
            }
        }

        LHU {
            encoding: imm[11:0] :: rs1[4:0] :: 0b101 :: rd[4:0] :: 0b0000011;
            args_disass:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + (signed<12>)imm;
                unsigned<16> res = (unsigned<16>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
                xtval_write(load_address);
            }
        }

        LWU { // 80000104: 0000ef03 lwu t5,0(ra)
            encoding: imm[11:0] :: rs1[4:0] :: 0b110 :: rd[4:0] :: 0b0000011;
            args_disass:"{name(rd)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> offs = X[rs1] + (signed<12>)imm;
                unsigned<32> res = (unsigned<32>)MEM[offs];
                if (rd != 0) X[rd] = (unsigned<XLEN>)res;
                xtval_write(load_address);
            }
        }

        SB {
            encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 0b000 :: imm[4:0] :: 0b0100011;
            args_disass:"{name(rs2)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1] + (signed<12>)imm;
                MEM[store_address] = (signed<8>)X[rs2];
                xtval_write(store_address);
            }
        }

        SH {
            encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 0b001 :: imm[4:0] :: 0b0100011;
            args_disass:"{name(rs2)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1] + (signed<12>)imm;
                MEM[store_address] = (signed<16>)X[rs2];
                xtval_write(store_address);
            }
        }

        SW {
            encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 0b010 :: imm[4:0] :: 0b0100011;
            args_disass:"{name(rs2)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1] + (signed<12>)imm;
                MEM[store_address] = (signed<32>)X[rs2];
                xtval_write(store_address);
            }
        }

        SD {
            encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: 0b011 :: imm[4:0] :: 0b0100011;
            args_disass:"{name(rs2)}, {imm}({name(rs1)})";
            behavior: {
                unsigned<XLEN> offs = X[rs1] + (signed<12>)imm;
                MEM[offs] = (signed<64>)X[rs2];
                xtval_write(store_address);
            }
        }
    }
}